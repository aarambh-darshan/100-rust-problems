# 60. 3Sum
**Difficulty**: Medium  
**Topics**: Arrays, Two Pointers, Sorting

## Problem Description

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

## Examples

### Example 1:
```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
```

### Example 2:
```
Input: nums = [0,1,1]
Output: []
```

### Example 3:
```
Input: nums = [0,0,0]
Output: [[0,0,0]]
```

## Constraints

- `3 <= nums.len() <= 3000`
- `-10^5 <= nums[i] <= 10^5`

## Hints

<details>
<summary>Hint 1</summary>
Sort the array first. This helps with deduplication and enables two-pointer technique.
</details>

<details>
<summary>Hint 2</summary>
Fix one element, then use two pointers to find pairs that sum to the negative of that element.
</details>

<details>
<summary>Hint 3</summary>
Skip duplicate elements to avoid duplicate triplets in the result.
</details>

## Function Signature

```rust
impl Solution {
    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {
        
    }
}
```
